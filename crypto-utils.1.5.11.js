var cryptoUtils=function(n){"use strict";const T=globalThis["crypto"],u=BigInt(0),w=BigInt(1),h=BigInt(2),l=BigInt(3),O=BigInt(8),y=Object.freeze({a:u,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:w,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),K=(n,t)=>(n+t/h)/t,V={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(n){var t=y["n"],r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),e=-w*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=r,s=BigInt("0x100000000000000000000000000000000"),o=K(a*n,t),f=K(-e*n,t);let c=x(n-o*r-f*i,t),u=x(-o*e-f*a,t);r=c>s,i=u>s;if(r&&(c=t-c),i&&(u=t-u),c>s||u>s)throw new Error("splitScalarEndo: Endomorphism failed, k="+n);return{k1neg:r,k1:c,k2neg:i,k2:u}}},a=32,o=32,q=a+1,D=2*a+1;function Z(n){var{a:t,b:r}=y,e=x(n*n),e=x(e*n);return x(e+t*n+r)}const j=y.a===u;class X extends Error{constructor(n){super(n)}}function Y(n){if(!(n instanceof m))throw new TypeError("JacobianPoint expected")}class m{constructor(n,t,r){this.x=n,this.y=t,this.z=r}static get BASE(){return new m(y.Gx,y.Gy,w)}static get ZERO(){return new m(u,w,u)}static fromAffine(n){if(n instanceof p)return n.equals(p.ZERO)?m.ZERO:new m(n.x,n.y,w);throw new TypeError("JacobianPoint#fromAffine: expected Point")}static toAffineBatch(n){const r=function(n,e=y.P){const i=new Array(n.length),t=E(n.reduce((n,t,r)=>t===u?n:x((i[r]=n)*t,e),w),e);return n.reduceRight((n,t,r)=>t===u?n:(i[r]=x(n*i[r],e),x(n*t,e)),t),i}(n.map(n=>n.z));return n.map((n,t)=>n.toAffine(r[t]))}static normalizeZ(n){return m.toAffineBatch(n).map(m.fromAffine)}equals(n){Y(n);var{x:t,y:r,z:e}=this,{x:n,y:i,z:a}=n,s=x(e*e),o=x(a*a),t=x(t*o),n=x(n*s),r=x(x(r*a)*o),a=x(x(i*e)*s);return t===n&&r===a}negate(){return new m(this.x,x(-this.y),this.z)}double(){var{x:n,y:t,z:r}=this,e=x(n*n),i=x(t*t),a=x(i*i),n=n+i,i=x(h*(x(n*n)-e-a)),n=x(l*e),e=x(n*n),e=x(e-h*i),n=x(n*(i-e)-O*a),i=x(h*t*r);return new m(e,n,i)}add(n){Y(n);var t,{x:r,y:e,z:i}=this,{x:a,y:s,z:o}=n;return a===u||s===u?this:r===u||e===u?n:(n=x(i*i),t=x(o*o),r=x(r*t),a=x(a*n),e=x(x(e*o)*t),t=x(x(s*i)*n),s=x(a-r),n=x(t-e),s===u?n===u?this.double():m.ZERO:(a=x(s*s),t=x(s*a),r=x(r*a),a=x(n*n-t-h*r),n=x(n*(r-a)-e*t),r=x(i*o*s),new m(a,n,r)))}subtract(n){return this.add(n.negate())}multiplyUnsafe(n){var r=m.ZERO;if("bigint"==typeof n&&n===u)return r;let e=Q(n);if(e===w)return this;if(!j){let n=r,t=this;for(;e>u;)e&w&&(n=n.add(t)),t=t.double(),e>>=w;return n}let{k1neg:t,k1:i,k2neg:a,k2:s}=V.splitScalar(e),o=r,f=r,c=this;for(;i>u||s>u;)i&w&&(o=o.add(c)),s&w&&(f=f.add(c)),c=c.double(),i>>=w,s>>=w;return t&&(o=o.negate()),a&&(f=f.negate()),f=new m(x(f.x*V.beta),f.y,f.z),o.add(f)}precomputeWindow(t){var r=j?128/t+1:256/t+1,e=[];let i=this,a=i;for(let n=0;n<r;n++){a=i,e.push(a);for(let n=1;n<2**(t-1);n++)a=a.add(i),e.push(a);i=a.double()}return e}wNAF(r,n){const e=(n=!n&&this.equals(m.BASE)?p.BASE:n)&&n._WINDOW_SIZE||1;if(256%e)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let i=n&&F.get(n),a=(i||(i=this.precomputeWindow(e),n&&1!==e&&(i=m.normalizeZ(i),F.set(n,i))),m.ZERO),s=m.BASE;var o=1+(j?128/e:256/e),f=2**(e-1),c=BigInt(2**e-1),u=2**e,h=BigInt(e);for(let t=0;t<o;t++){const e=t*f;let n=Number(r&c);r>>=h,n>f&&(n-=u,r+=w);var l=e,y=e+Math.abs(n)-1,d=t%2!=0,g=n<0;0===n?s=s.add(W(d,i[l])):a=a.add(W(g,i[y]))}return{p:a,f:s}}multiply(n,t){let r,e,i=Q(n);if(j){const{k1neg:n,k1:c,k2neg:u,k2:h}=V.splitScalar(i);var{p:a,f:s}=this.wNAF(c,t),{p:o,f}=this.wNAF(h,t),a=W(n,a),o=W(u,o);o=new m(x(o.x*V.beta),o.y,o.z),r=a.add(o),e=s.add(f)}else{const{p:n,f:l}=this.wNAF(i,t);r=n,e=l}return m.normalizeZ([r,e])[0]}toAffine(n){var{x:t,y:r,z:e}=this,i=this.equals(m.ZERO),n=n=null==n?i?O:E(e):n,a=x(n*n),s=x(a*n),t=x(t*a),a=x(r*s),r=x(e*n);if(i)return p.ZERO;if(r!==w)throw new Error("invZ was invalid");return new p(t,a)}}function W(n,t){var r=t.negate();return n?r:t}const F=new WeakMap;let p=class{constructor(n,t){this.x=n,this.y=t}_setWindowSize(n){this._WINDOW_SIZE=n,F.delete(this)}static get BASE(){return new p(y.Gx,y.Gy)}static get ZERO(){return new p(u,u)}hasEvenY(){return this.y%h===u}static fromCompressedHex(n){var t=32===n.length,r=v(t?n:n.subarray(1));if(!rn(r))throw new Error("Point is not on curve");let e=function(n){var t=y["P"],r=BigInt(6),e=BigInt(11),i=BigInt(22),a=BigInt(23),s=BigInt(44),o=BigInt(88),f=n*n*n%t,c=f*f*n%t,u=A(c,l)*c%t,u=A(u,l)*c%t,u=A(u,h)*f%t,e=A(u,e)*u%t,u=A(e,i)*e%t,i=A(u,s)*u%t,o=A(i,o)*i%t,i=A(o,s)*u%t,o=A(i,l)*c%t,s=A(o,a)*e%t,u=A(s,r)*f%t,i=A(u,h);if(i*i%t!==n)throw new Error("Cannot find square root");return i}(Z(r));var i=(e&w)===w,t=(t?i&&(e=x(-e)):1==(1&n[0])!=i&&(e=x(-e)),new p(r,e));return t.assertValidity(),t}static fromUncompressedHex(n){var t=v(n.subarray(1,a+1)),n=v(n.subarray(a+1,2*a+1)),t=new p(t,n);return t.assertValidity(),t}static fromHex(n){var n=b(n),t=n.length,r=n[0];if(t===a)return this.fromCompressedHex(n);if(t===q&&(2===r||3===r))return this.fromCompressedHex(n);if(t===D&&4===r)return this.fromUncompressedHex(n);throw new Error(`Point.fromHex: received invalid point. Expected 32-${q} compressed bytes or ${D} uncompressed bytes, not `+t)}static fromPrivateKey(n){return p.BASE.multiply(B(n))}static fromSignature(n,t,r){var{r:t,s:e}=sn(t);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");var n=nn(b(n)),i=y["n"],t=2===r||3===r?t+i:t,a=E(t,i),n=x(-n*a,i),e=x(e*a,i),a=1&r?"03":"02",i=p.fromHex(a+c(t)),r=p.BASE.multiplyAndAddUnsafe(i,n,e);if(r)return r.assertValidity(),r;throw new Error("Cannot recover signature: point at infinify")}toRawBytes(n=!1){return r(this.toHex(n))}toHex(n=!1){var t=c(this.x);return n?(this.hasEvenY()?"02":"03")+t:"04"+t+c(this.y)}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){var n="Point is not on elliptic curve",{x:t,y:r}=this;if(!rn(t)||!rn(r))throw new Error(n);r=x(r*r);if(x(r-Z(t))!==u)throw new Error(n)}equals(n){return this.x===n.x&&this.y===n.y}negate(){return new p(this.x,x(-this.y))}double(){return m.fromAffine(this).double().toAffine()}add(n){return m.fromAffine(this).add(m.fromAffine(n)).toAffine()}subtract(n){return this.add(n.negate())}multiply(n){return m.fromAffine(this).multiply(n,this).toAffine()}multiplyAndAddUnsafe(n,t,r){var e=m.fromAffine(this),e=t===u||t===w||this!==p.BASE?e.multiplyUnsafe(t):e.multiply(t),t=m.fromAffine(n).multiplyUnsafe(r),n=e.add(t);return n.equals(m.ZERO)?void 0:n.toAffine()}};function M(n){return 8<=Number.parseInt(n[0],16)?"00"+n:n}function J(n){if(n.length<2||2!==n[0])throw new Error("Invalid signature integer tag: "+e(n));var t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:v(r),left:n.subarray(t+2)}}class f{constructor(n,t){this.r=n,this.s=t,this.assertValidity()}static fromCompact(n){var t=n instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof n&&!t)throw new TypeError(r+": Expected string or Uint8Array");t=t?e(n):n;if(128!==t.length)throw new Error(r+": Expected 64-byte hex");return new f(G(t.slice(0,64)),G(t.slice(64,128)))}static fromDER(n){var t=n instanceof Uint8Array;if("string"==typeof n||t)return{r:t,s:n}=function(n){if(n.length<2||48!=n[0])throw new Error("Invalid signature tag: "+e(n));if(n[1]!==n.length-2)throw new Error("Invalid signature: incorrect length");var{data:n,left:t}=J(n.subarray(2)),{data:t,left:r}=J(t);if(r.length)throw new Error("Invalid signature: left bytes after parsing: "+e(r));return{r:n,s:t}}(t?n:r(n)),new f(t,n);throw new TypeError("Signature.fromDER: Expected string or Uint8Array")}static fromHex(n){return this.fromDER(n)}assertValidity(){var{r:n,s:t}=this;if(!S(n))throw new Error("Invalid Signature: r must be 0 < r < n");if(!S(t))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){var n=y.n>>w;return this.s>n}normalizeS(){return this.hasHighS()?new f(this.r,x(-this.s,y.n)):this}toDERRawBytes(){return r(this.toDERHex())}toDERHex(){var n=M(g(this.s)),t=M(g(this.r)),r=n.length/2,e=t.length/2,i=g(r),a=g(e);return`30${g(e+r+4)}02${a}${t}02`+i+n}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return r(this.toCompactHex())}toCompactHex(){return c(this.r)+c(this.s)}}function s(...r){if(!r.every(n=>n instanceof Uint8Array))throw new Error("Uint8Array list expected");if(1===r.length)return r[0];var n=r.reduce((n,t)=>n+t.length,0),e=new Uint8Array(n);for(let n=0,t=0;n<r.length;n++){var i=r[n];e.set(i,t),t+=i.length}return e}const L=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function e(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let r="";for(let n=0;n<t.length;n++)r+=L[t[n]];return r}const $=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function c(n){if("bigint"!=typeof n)throw new Error("Expected bigint");if(u<=n&&n<$)return n.toString(16).padStart(64,"0");throw new Error("Expected number 0 <= n < 2^256")}function d(n){n=r(c(n));if(32!==n.length)throw new Error("Error: expected 32 bytes");return n}function g(n){n=n.toString(16);return 1&n.length?"0"+n:n}function G(n){if("string"!=typeof n)throw new TypeError("hexToNumber: expected string, got "+typeof n);return BigInt("0x"+n)}function r(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);var r=new Uint8Array(t.length/2);for(let n=0;n<r.length;n++){var e=2*n,e=t.slice(e,2+e),e=Number.parseInt(e,16);if(Number.isNaN(e)||e<0)throw new Error("Invalid byte sequence");r[n]=e}return r}function v(n){return G(e(n))}function b(n){return n instanceof Uint8Array?Uint8Array.from(n):r(n)}function Q(n){if("number"==typeof n&&Number.isSafeInteger(n)&&0<n)return BigInt(n);if("bigint"==typeof n&&S(n))return n;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function x(n,t=y.P){n%=t;return n>=u?n:t+n}function A(n,t){var r=y["P"];let e=n;for(;t-- >u;)e=e*e%r;return e}function E(n,t=y.P){if(n===u||t<=u)throw new Error(`invert: expected positive integers, got n=${n} mod=`+t);let r=x(n,t),e=t,i=u,a=w;for(;r!==u;){const n=e%r,t=i-a*(e/r);e=r,r=n,i=a,a=t}if(e!==w)throw new Error("invert: does not exist");return x(i,t)}function nn(n,t=!1){r=8*(n=n).length-8*o,n=v(n);var r=0<r?n>>BigInt(r):n;return!t&&(n=y.n,n<=r)?r-n:r}let i,t;class tn{constructor(n,t){if(this.hashLen=n,this.qByteLen=t,"number"!=typeof n||n<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(n).fill(1),this.k=new Uint8Array(n).fill(0),this.counter=0}hmac(...n){return I.hmacSha256(this.k,...n)}hmacSync(...n){return t(this.k,...n)}checkSync(){if("function"!=typeof t)throw new X("hmacSha256Sync needs to be set")}incr(){if(1e3<=this.counter)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(n=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),n),this.v=await this.hmac(this.v),0!==n.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),n),this.v=await this.hmac(this.v))}reseedSync(n=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),n),this.v=this.hmacSync(this.v),0!==n.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),n),this.v=this.hmacSync(this.v))}async generate(){this.incr();let n=0;for(var t=[];n<this.qByteLen;){this.v=await this.hmac(this.v);var r=this.v.slice();t.push(r),n+=this.v.length}return s(...t)}generateSync(){this.checkSync(),this.incr();let n=0;for(var t=[];n<this.qByteLen;){this.v=this.hmacSync(this.v);var r=this.v.slice();t.push(r),n+=this.v.length}return s(...t)}}function S(n){return u<n&&n<y.n}function rn(n){return u<n&&n<y.P}function en(r,n,t,e=!0){var i=y["n"],r=nn(r,!0);if(S(r)){var a=E(r,i),r=p.BASE.multiply(r),s=x(r.x,i);if(s!==u){a=x(a*x(n+t*s,i),i);if(a!==u){let n=new f(s,a),t=(r.x===n.r?0:2)|Number(r.y&w);return e&&n.hasHighS()&&(n=n.normalizeS(),t^=1),{sig:n,recovery:t}}}}}function B(n){let t;if("bigint"==typeof n)t=n;else if("number"==typeof n&&Number.isSafeInteger(n)&&0<n)t=BigInt(n);else if("string"==typeof n){if(n.length!==2*o)throw new Error("Expected 32 bytes of private key");t=G(n)}else{if(!(n instanceof Uint8Array))throw new TypeError("Expected valid private key");if(n.length!==o)throw new Error("Expected 32 bytes of private key");t=v(n)}if(S(t))return t;throw new Error("Expected private key: 0 < key < n")}function an(n){return n instanceof p?(n.assertValidity(),n):p.fromHex(n)}function sn(t){if(t instanceof f)return t.assertValidity(),t;try{return f.fromDER(t)}catch(n){return f.fromCompact(t)}}function on(n){var t=n instanceof Uint8Array,r="string"==typeof n,e=(t||r)&&n.length;return t?e===q||e===D:r?e===2*q||e===2*D:n instanceof p}function fn(n,t,r=!1){if(on(n))throw new TypeError("getSharedSecret: first arg must be private key");if(on(t))return(t=an(t)).assertValidity(),t.multiply(B(n)).toRawBytes(r);throw new TypeError("getSharedSecret: second arg must be public key")}function cn(n){return v(n.length>a?n.slice(0,a):n)}function un(n){return d(n)}function hn(n,t,r){if(null==n)throw new Error(`sign: expected valid message hash, not "${n}"`);var e,n=b(n),t=B(t),i=[un(t),un((e=x(i=cn(i=n),y.n))<u?i:e)];if(null!=r){const n=b(r=!0===r?I.randomBytes(a):r);if(n.length!==a)throw new Error(`sign: Expected ${a} bytes of extra data`);i.push(n)}return{seed:s(...i),m:cn(n),d:t}}function ln(n,t){var{sig:n,recovery:r}=n,{der:t,recovered:e}=Object.assign({canonical:!0,der:!0},t),t=t?n.toDERRawBytes():n.toCompactRawBytes();return e?[t,r]:t}async function yn(n,t,r={}){var{seed:n,m:e,d:i}=hn(n,t,r.extraEntropy),a=new tn(32,o);let s;for(await a.reseed(n);!(s=en(await a.generate(),e,i,r.canonical));)await a.reseed();return ln(s,r)}const dn={strict:!0};function gn(n,t,r,e=dn){let i;try{i=sn(n),t=b(t)}catch(n){return!1}var{r:a,s}=i;if(e.strict&&i.hasHighS())return!1;e=nn(t);let o;try{o=an(r)}catch(n){return!1}t=y.n,r=E(s,t),s=x(e*r,t),e=x(a*r,t),r=p.BASE.multiplyAndAddUnsafe(o,s,e);return!!r&&x(r.x,t)===a}function wn(n){return x(v(n),y.n)}class U{constructor(n,t){this.r=n,this.s=t,this.assertValidity()}static fromHex(n){n=b(n);if(64!==n.length)throw new TypeError("SchnorrSignature.fromHex: expected 64 bytes, not "+n.length);var t=v(n.subarray(0,32)),n=v(n.subarray(32,64));return new U(t,n)}assertValidity(){var{r:n,s:t}=this;if(!rn(n)||!S(t))throw new Error("Invalid signature")}toHex(){return c(this.r)+c(this.s)}toRawBytes(){return r(this.toHex())}}class mn{constructor(n,t,r=I.randomBytes()){if(null==n)throw new TypeError(`sign: Expected valid message, not "${n}"`);this.m=b(n);var{x:n,scalar:t}=this.getScalar(B(t));if(this.px=n,this.d=t,this.rand=b(r),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(n){var t=p.fromPrivateKey(n),n=t.hasEvenY()?n:y.n-n;return{point:t,scalar:n,x:t.toRawX()}}initNonce(n,t){return d(n^v(t))}finalizeNonce(n){n=x(v(n),y.n);if(n===u)throw new Error("sign: Creation of signature failed. k is zero");var{point:n,x:t,scalar:r}=this.getScalar(n);return{R:n,rx:t,k:r}}finalizeSig(n,t,r,e){return new U(n.x,x(t+r*e,y.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){var{m:n,d:t,px:r,rand:e}=this,i=I.taggedHash,e=this.initNonce(t,await i(H.aux,e)),{R:e,rx:a,k:s}=this.finalizeNonce(await i(H.nonce,e,r,n)),i=wn(await i(H.challenge,a,r,n)),a=this.finalizeSig(e,s,i,t);return await bn(a,n,r)||this.error(),a}calcSync(){var{m:n,d:t,px:r,rand:e}=this,i=I.taggedHashSync,e=this.initNonce(t,i(H.aux,e)),{R:e,rx:a,k:s}=this.finalizeNonce(i(H.nonce,e,r,n)),i=wn(i(H.challenge,a,r,n)),a=this.finalizeSig(e,s,i,t);return xn(a,n,r)||this.error(),a}}function pn(n,t,r){var e=n instanceof U,n=e?n:U.fromHex(n);return e&&n.assertValidity(),{...n,m:b(t),P:an(r)}}function vn(n,t,r,e){t=p.BASE.multiplyAndAddUnsafe(t,B(r),x(-e,y.n));return!(!t||!t.hasEvenY()||t.x!==n)}async function bn(n,t,r){try{var{r:e,s:i,m:a,P:s}=pn(n,t,r),o=wn(await I.taggedHash(H.challenge,d(e),s.toRawX(),a));return vn(e,s,i,o)}catch(n){return!1}}function xn(n,t,r){try{var{r:e,s:i,m:a,P:s}=pn(n,t,r),o=wn(I.taggedHashSync(H.challenge,d(e),s.toRawX(),a));return vn(e,s,i,o)}catch(n){if(n instanceof X)throw n;return!1}}const An={Signature:U,getPublicKey:function(n){return p.fromPrivateKey(n).toRawX()},sign:async function(n,t,r){return new mn(n,t,r).calc()},verify:bn,signSync:function(n,t,r){return new mn(n,t,r).calcSync()},verifySync:xn},H=(p.BASE._setWindowSize(8),{challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"}),En={},I={bytesToHex:e,hexToBytes:r,concatBytes:s,mod:x,invert:E,isValidPrivateKey(n){try{return B(n),!0}catch(n){return!1}},_bigintTo32Bytes:d,_normalizePrivateKey:B,hashToPrivateKey:n=>{n=b(n);var t=o+8;if(n.length<t||1024<n.length)throw new Error("Expected valid bytes of private key as per FIPS 186");return d(x(v(n),y.n-w)+w)},randomBytes:(n=32)=>T.getRandomValues(new Uint8Array(n)),randomPrivateKey:()=>I.hashToPrivateKey(I.randomBytes(o+8)),precompute(n=8,t=p.BASE){t=t===p.BASE?t:new p(t.x,t.y);return t._setWindowSize(n),t.multiply(l),t},sha256:async(...n)=>{n=await T.subtle.digest("SHA-256",s(...n));return new Uint8Array(n)},hmacSha256:async(n,...t)=>{n=await T.subtle.importKey("raw",n,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),t=s(...t),n=await T.subtle.sign("HMAC",n,t);return new Uint8Array(n)},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(n,...t)=>{let r=En[n];if(void 0===r){const t=await I.sha256(Uint8Array.from(n,n=>n.charCodeAt(0)));r=s(t,t),En[n]=r}return I.sha256(r,...t)},taggedHashSync:(n,...t)=>{if("function"!=typeof i)throw new X("sha256Sync is undefined, you need to set it");let r=En[n];if(void 0===r){const t=i(Uint8Array.from(n,n=>n.charCodeAt(0)));r=s(t,t),En[n]=r}return i(r,...t)},_JacobianPoint:m};Object.defineProperties(I,{sha256Sync:{configurable:!1,get:()=>i,set(n){i=i||n}},hmacSha256Sync:{configurable:!1,get:()=>t,set(n){t=t||n}}});var Sn=Object.freeze({__proto__:null,CURVE:y,Point:p,Signature:f,getPublicKey:function(n,t=!1){return p.fromPrivateKey(n).toRawBytes(t)},getSharedSecret:fn,recoverPublicKey:function(n,t,r,e=!1){return p.fromSignature(n,t,r).toRawBytes(e)},schnorr:An,sign:yn,signSync:function(n,t,r={}){var{seed:n,m:e,d:i}=hn(n,t,r.extraEntropy),a=new tn(32,o);let s;for(a.reseedSync(n);!(s=en(a.generateSync(),e,i,r.canonical));)a.reseedSync();return ln(s,r)},utils:I,verify:gn});const Bn=new TextEncoder,Un=[{name:"base58",charset:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"},{name:"base64",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"},{name:"base64url",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}];function Hn(n){for(const t of Un)if(t.name===n)return t.charset;throw TypeError("Charset does not exist: "+n)}const z={encode:function(n,t,r=!1){"string"==typeof n&&(n=Bn.encode(n));var e=Hn(t),i=e.length,a=[];let s,o,f,c="",u=0;for(s=0;s<n.length;s++)for(u=0,o=n[s],c+=0<o||0<(c.length^s)?"":"1";u in a||0<o;)f=0<(f=a[u])?256*f+o:o,o=f/i|0,a[u]=f%i,u++;for(;0<u--;)c+=e[a[u]];return r&&0<c.length%4?c+"=".repeat(4-c.length%4):c},decode:function(n,t){var r=Hn(t),e=r.length,i=[],a=[];n=n.replace("=","");let s,o,f,c=0;for(s=0;s<n.length;s++){if(c=0,(o=r.indexOf(n[s]))<0)throw new Error("Character range out of bounds: "+o);for(0<o||0<(a.length^s)||a.push(0);c in i||0<o;)f=0<(f=i[c])?f*e+o:o,o=f>>8,i[c]=f%256,c++}for(;0<c--;)a.push(i[c]);return new Uint8Array(a)}},In="qpzry9x8gf2tvdw0s3jn54khce6mua7l",zn=[996825010,642813549,513874426,1027748829,705979059],Nn={BECH32:"bech32",BECH32M:"bech32m"};function Rn(n){switch(n){case Nn.BECH32:return 1;case Nn.BECH32M:return 734539939;default:throw new Error("Unrecognized encoding: "+n)}}function _n(t){let r=1;for(let n=0;n<t.length;++n){var e=r>>25;r=(33554431&r)<<5^t[n];for(let n=0;n<5;++n)0<(e>>n&1)&&(r^=zn[n])}return r}function kn(n){var t=[];let r;for(r=0;r<n.length;++r)t.push(n.charCodeAt(r)>>5);for(t.push(0),r=0;r<n.length;++r)t.push(31&n.charCodeAt(r));return t}function Pn(n,t,r,e=!0){var i=[];let a=0,s=0;var o=(1<<r)-1,f=(1<<t+r-1)-1;for(const e of n){if(e<0||0<e>>t)return[];for(a=(a<<t|e)&f,s+=t;s>=r;)s-=r,i.push(a>>s&o)}if(e)0<s&&i.push(a<<r-s&o);else if(s>=t||0<(a<<r-s&o))return[];return i}function Cn(n,t=0){var r=n.split("1",1)[0],{hrp:n,data:e}=function(t,n){const r=0<n?"bech32m":"bech32";if(!function(n){let t,r,e=!1,i=!1;for(t=0;t<n.length;++t){if((r=n.charCodeAt(t))<33||126<r)return;97<=r&&r<=122&&(e=!0),65<=r&&r<=90&&(i=!0)}return!e||!i}(t))return{hrp:null,data:[255]};if(n=t=t.toLowerCase(),(a=n.lastIndexOf("1"))<1||a+7>n.length||90<n.length)return{hrp:null,data:[255]};var e,i=[],a=t.lastIndexOf("1"),n=t.substring(0,a);for(let n=a+1;n<t.length;++n){const r=In.indexOf(t.charAt(n));if(-1===r)return{hrp:null,data:[255]};i.push(r)}return a=i,e=r,_n(kn(n).concat(a))===Rn(e)?{hrp:n,data:i.slice(0,i.length-6)}:{hrp:null,data:[255]}}(n,t),i=Pn(e.slice(1),5,8,!1),a=i.length;switch(!0){case r!==n:throw new Error("Returned hrp string is invalid.");case null===i||a<2||40<a:throw new Error("Decoded string is invalid or out of spec.");case 16<e[0]:throw new Error("Returned version bit is out of range.");case 0===e[0]&&20!==a&&32!==a:throw new Error("Decoded string does not match version 0 spec.");case 0===e[0]&&0!==t:case 0!==e[0]&&1!==t:throw new Error("Decoded version bit does not match.");default:return Uint8Array.from(i)}}const Tn={encode:function(n,t="bch",r=0){t=function(i,n,t){var r=n.concat(function(n,t){var r=_n(kn(i).concat(n).concat([0,0,0,0,0,0]))^Rn(t),e=[];for(let n=0;n<6;++n)e.push(r>>5*(5-n)&31);return e}(n,t));let e=i+"1";for(let n=0;n<r.length;++n)e+=In.charAt(r[n]);return e}(t,[r,...Pn([...n],8,5)],0<r?"bech32m":"bech32");return Cn(t,r),t},decode:Cn},On=new TextEncoder,Kn=new TextDecoder;function Vn(n){return On.encode(n)}function qn(n){var t=[];let r,e=0;if(0<n.length%2)throw new Error("Invalid hex string length: "+n.length);for(r=0;r<n.length;r+=2)t[e]=parseInt(n.slice(r,r+2),16),e+=1;return Uint8Array.from(t)}function Dn(n){for(var t=[];0<n;){var r=255&n;t.push(r),n=(n-r)/256}return Uint8Array.from(t)}function Zn(n){for(var t=[];0n<n;){var r=0xffn&n;t.push(Number(r)),n=(n-r)/256n}return Uint8Array.from(t)}function jn(n){return Kn.decode(n)}async function Xn(n){return crypto.subtle.digest("SHA-256",n).then(n=>new Uint8Array(n))}async function Yn(n){return Xn(await Xn(n))}const Wn=globalThis["crypto"];class N extends Uint8Array{static{this.num=(n,t,r="le")=>new N(Dn(n),t,r)}static{this.big=(n,t,r="le")=>new N(Zn(n),t,r)}static async b58check(n){n=z.decode(n,"base58");return new N(await async function(n){var t=n.slice(0,-4),n=n.slice(-4);if((await Yn(t)).slice(0,4).toString()!==n.toString())throw new Error("Invalid checksum!");return t}(n))}static{this.buff=(n,t)=>new N(function(n){if(n instanceof ArrayBuffer)return new Uint8Array(n);if(n instanceof Uint8Array)return n;var t=typeof n;switch(t){case"bigint":return Zn(n);case"boolean":return Uint8Array.of(n);case"number":return Dn(n);case"string":return null!==n.match(/^(02|03)*[0-9a-fA-F]{64}$/)?qn(n):On.encode(n);default:throw TypeError("Unsupported format:"+t)}}(n),t)}static{this.raw=(n,t)=>new N(n,t)}static{this.str=(n,t)=>new N(Vn(n),t)}static{this.hex=(n,t)=>new N(qn(n),t)}static{this.json=n=>new N(Vn(JSON.stringify(n)))}static{this.base64=n=>new N(z.decode(n,"base64"))}static{this.b64url=n=>new N(z.decode(n,"base64url"))}static{this.bech32=(n,t)=>new N(Tn.decode(n,t))}constructor(n,t=null,r="be"){if(null!==t){const r=new Uint8Array(t).fill(0);r.set(new Uint8Array(n)),n=r.buffer}return super(n="le"===r?new Uint8Array(n).reverse():n),this}get num(){return this.toNum()}get big(){return this.toBig()}get arr(){return this.toArr()}get str(){return this.toStr()}get hex(){return this.toHex()}get raw(){return new Uint8Array(this)}get hash(){return this.toHash()}get id(){return this.toHash().then(n=>new N(n).hex)}toNum(r="le"){{var e="le"===r?this.reverse():this;let n,t=0;for(n=e.length-1;0<=n;n--)t=256*t+e[n];return Number(t)}}toBig(r="le"){{var e="le"===r?this.reverse():this;let n,t=0n;for(n=e.length-1;0<=n;n--)t=256n*t+BigInt(e[n]);return BigInt(t)}}async toHash(){return Wn.subtle.digest("SHA-256",this.raw).then(n=>new Uint8Array(n))}async tob58check(){return z.encode((t=await Yn(n=this),await Uint8Array.of(...n,...t.slice(0,4))),"base58");var n,t}toArr(){return Array.from(this)}toStr(){return jn(this)}toHex(){{var t=this,r=[];let n;for(n=0;n<t.length;n++)r.push(t[n].toString(16).padStart(2,"0"));return r.join("")}}toJson(){return JSON.parse(jn(this))}toBytes(){return new Uint8Array(this)}toB64url(){return z.encode(this,"base64url")}toBase64(n){return z.encode(this,"base64",n)}toBech32(n,t){return Tn.encode(this,n,t)}prepend(n){return N.of(...n,...this)}append(n){return N.of(...this,...n)}slice(n,t){return new N(new Uint8Array(this).slice(n,t))}reverse(){return new N(new Uint8Array(this).reverse())}write(n,t){this.set(n,t)}prependVarint(n=this.length){return N.of(...N.readVarint(n),...this)}static from(n){return new N(Uint8Array.from(n))}static of(...n){return new N(Uint8Array.of(...n))}static join(n){let t,r=0;const e=n.reduce((n,t)=>n+t.length,0),i=new Uint8Array(e);for(const e of n)for(t=0;t<e.length;r++,t++)i[r]=e[t];return new N(i,e)}static readVarint(n){if(n<253)return N.num(n,1);if(n<65536)return N.of(253,...N.num(n,2));if(n<4294967296)return N.of(254,...N.num(n,4));if(n<0x10000000000000000)return N.of(255,...N.num(n,8));throw new Error("Value is too large: "+n)}static random(n=32){return new N(Wn.getRandomValues(new Uint8Array(n)))}static{this.encode=Vn}static{this.decode=jn}static normalize(n,t){if(n instanceof Uint8Array)return n;if("string"==typeof n)return N.hex(n,t).toBytes();if("number"==typeof n)return N.num(n,t).toBytes();if("bigint"==typeof n)return N.big(n,t).toBytes();throw TypeError("Unrecognized format: "+typeof n)}static serialize(n){if("string"==typeof n)return N.str(n).toBytes();if("object"==typeof n){if(n instanceof Uint8Array)return n;try{return N.json(n).toBytes()}catch{throw TypeError("Object is not serializable.")}}throw TypeError("Unrecognized format: "+typeof n)}static revitalize(n){if("string"==typeof(n=n instanceof Uint8Array?jn(n):n))try{return JSON.parse(n)}catch{}return n}}const Fn=globalThis.crypto;async function Mn(n,t){return fn(N.normalize(n),N.normalize(t),!0)}async function Jn(n){return Fn.subtle.importKey("raw",N.normalize(n),{name:"AES-CBC"},!0,["encrypt","decrypt"])}const R={ecdh:Mn,import:Jn,export:async function(n){return Fn.subtle.exportKey("raw",n).then(n=>new Uint8Array(n))},hmac:async function(n,t="SHA-256"){t={name:"HMAC",hash:t};return Fn.subtle.importKey("raw",N.normalize(n),t,!1,["sign","verify"])},shared:async function(n,t){return Jn((await Mn(n,t)).slice(1,33))},generate:async function(){return Jn(N.random(32))},normalize:async function(n){return n instanceof CryptoKey?n:R.import(n)}},Ln=globalThis.crypto;class _{static async fromSecret(n){n=await R.normalize(n);return new _(n)}static async fromShared(n,t){n=await R.shared(n,t);return new _(n)}static async encrypt(n,t,r){const e=N.normalize(t),i=await R.normalize(n),a=void 0!==r?N.normalize(r):N.random(16);return Ln.subtle.encrypt({name:"AES-CBC",iv:a},i,e).then(n=>Uint8Array.of(...a,...new Uint8Array(n)))}static async decrypt(n,t,r){var t=N.normalize(t),n=await R.normalize(n),e=void 0!==r?t:t.slice(16),r=void 0!==r?N.normalize(r):t.slice(0,16);return Ln.subtle.decrypt({name:"AES-CBC",iv:r},n,e).then(n=>new Uint8Array(n))}constructor(n){this.key=n}get secretKey(){return R.export(this.key)}get secretHex(){return this.secretKey.then(n=>N.buff(n).toHex())}async encrypt(n,t){return _.encrypt(this.key,n,t)}async decrypt(n,t){return _.decrypt(this.key,n,t)}}class k extends Uint8Array{static{this.N=y.n}static mod(n,t=k.N){return I.mod(n,t)}static{this.isField=n=>n instanceof k}static normalize(n){return n=C(n),n=k.mod(n),n=I._normalizePrivateKey(n),N.big(n,32).raw}static validate(n){return I.isValidPrivateKey(n)}constructor(n){super(n=k.normalize(n))}get buff(){return new N(this)}get raw(){return this}get num(){return this.buff.toBig()}get point(){return P.fromNum(this.num)}get hasOddY(){return this.point.hasOddY}get negated(){return this.hasOddY?this.negate():this}gt(n){return new k(n).num>this.num}lt(n){return new k(n).num<this.num}eq(n){return new k(n).num===this.num}ne(n){return new k(n).num!==this.num}add(n){n=new k(n);return new k(this.num+n.num)}sub(n){n=new k(n);return new k(this.num-n.num)}mul(n){n=new k(n);return new k(this.num*n.num)}pow(n,t=k.N-1n){n=new k(n),n=k.mod(n.num,t);return new k(this.num**n)}div(n){n=new k(n),n=this.pow(n.num,k.N-2n);return new k(this.num*n.num)}negate(){return new k(k.N-this.num)}}class P{static{this.N=y.n}static validate(n){try{n=C(n);var t=N.big(n).toHex();return p.fromHex(t).assertValidity(),!0}catch{return!1}}static fromNum(n){n=C(n);n=I.mod(n,P.N),n=p.BASE.multiply(n);return new P(n.x,n.y)}static fromX(n){n=C(n);n=N.big(n).toHex();return P.from(p.fromHex(n))}static from(n){return new P(n.x,n.y)}constructor(n,t){this.__p=new p(n,t),this.__x=this.__p.x,this.__y=this.__p.y,this.__p.assertValidity()}get p(){return this.__p}get buff(){return new N(this.rawX.slice(1))}get hex(){return this.buff.hex}get hasOddY(){return!this.__p.hasEvenY()}get rawX(){var n=this.__p.hasEvenY()?2:3,t=N.big(this.__x);return Uint8Array.of(n,...t)}get rawY(){return N.big(this.__y)}get x(){return this.__x}get y(){return this.__y}eq(n){return n instanceof P?this.p.equals(new p(n.x,n.y)):n instanceof Uint8Array?this.x.toString()===n.toString():"number"==typeof n?BigInt(n)===this.x:n===this.x}add(n){return n instanceof P?P.from(this.p.add(n.p)):P.from(this.p.add(P.fromNum(n).p))}sub(n){return n instanceof P?P.from(this.p.subtract(n.p)):P.from(this.p.subtract(P.fromNum(n).p))}mul(n){return n instanceof P?P.from(this.p.multiply(n.x)):P.from(this.p.multiply(C(n)))}negate(){return P.from(this.__p.negate())}}function C(n){if(n instanceof Uint8Array)return N.raw(n).big;if("string"==typeof n)return N.hex(n).big;if("number"==typeof n)return BigInt(n);if("bigint"==typeof n)return n;throw TypeError("Invalid input type:"+typeof n)}async function $n(n,t,r="schnorr"){n=N.normalize(n),t=N.normalize(t);return"schnorr"===r?An.sign(n,t):yn(n,t)}async function Gn(n,t,r,e="schnorr"){n=N.normalize(n),t=N.normalize(t),r=N.normalize(r);return"schnorr"===e?An.verify(r,n,32<(e=t).length?e.slice(1):e):gn(r,n,t)}class Qn{static generate(){return new Qn(N.random(32))}constructor(n){this._buffer=N.normalize(n,32)}get field(){return new k(this._buffer)}get point(){return this.field.point}get buff(){return new N(this._buffer)}get raw(){return new Uint8Array(this._buffer)}get hex(){return this.buff.hex}get pub(){return new nt(this.point.rawX)}async sign(n,t){return $n(N.normalize(n),this.raw,t)}async verify(n,t,r){return Gn(n,this.pub.raw,t,r)}}class nt{static generate(){return new Qn(N.random(32)).pub}constructor(n){this._buffer=N.normalize(n)}get raw(){return new Uint8Array(this._buffer)}get rawX(){return 32<this.raw.length?this.raw.slice(1,33):this.raw}get buff(){return new N(this.raw)}get hex(){return this.buff.hex}async verify(n,t,r){return Gn(n,this.raw,t,r)}}function tt(n,t=0){for(var r=[];0<n;){const t=0xffn&n;r.push(t),n=(n-t)/256n}let e=Uint8Array.from(r.map(n=>Number(n)));if(0!==t){const n=new Uint8Array(t);n.set(e),e=n}return e}const rt=[0n,1n,2n,3n,4n,5n,6n,7n,8n,9n,10n,11n,12n,13n,14n,15n,7n,4n,13n,1n,10n,6n,15n,3n,12n,0n,9n,5n,2n,14n,11n,8n,3n,10n,14n,4n,9n,15n,8n,1n,2n,7n,0n,6n,13n,11n,5n,12n,1n,9n,11n,10n,0n,8n,12n,4n,13n,3n,7n,15n,14n,5n,6n,2n,4n,0n,5n,9n,7n,12n,2n,10n,14n,1n,3n,8n,11n,6n,15n,13n],et=[5n,14n,7n,0n,9n,2n,11n,4n,13n,6n,15n,8n,1n,10n,3n,12n,6n,11n,3n,7n,0n,13n,5n,10n,14n,15n,8n,12n,4n,9n,1n,2n,15n,5n,1n,3n,7n,14n,6n,9n,11n,8n,12n,2n,10n,0n,4n,13n,8n,6n,4n,1n,3n,11n,15n,0n,5n,12n,2n,13n,9n,7n,10n,14n,12n,15n,10n,4n,1n,5n,8n,7n,6n,2n,13n,14n,0n,3n,9n,11n],it=[11n,14n,15n,12n,5n,8n,7n,9n,11n,13n,14n,15n,6n,7n,9n,8n,7n,6n,8n,13n,11n,9n,7n,15n,7n,12n,15n,9n,11n,7n,13n,12n,11n,13n,6n,7n,14n,9n,13n,15n,14n,8n,13n,6n,5n,12n,7n,5n,11n,12n,14n,15n,14n,15n,9n,8n,9n,14n,5n,6n,8n,6n,5n,12n,9n,15n,5n,11n,6n,8n,13n,12n,5n,12n,13n,14n,11n,8n,5n,6n],at=[8n,9n,9n,11n,13n,15n,15n,5n,7n,7n,8n,11n,14n,14n,12n,6n,9n,13n,15n,7n,12n,8n,9n,11n,7n,7n,12n,7n,6n,15n,13n,11n,9n,7n,15n,11n,8n,6n,6n,14n,12n,13n,5n,14n,13n,13n,7n,5n,15n,5n,8n,11n,14n,14n,6n,14n,6n,9n,12n,9n,12n,5n,15n,8n,8n,5n,12n,9n,12n,5n,14n,6n,8n,13n,6n,5n,15n,13n,11n,11n],st=[0n,0x5a827999n,0x6ed9eba1n,0x8f1bbcdcn,0xa953fd4en],ot=[0x50a28be6n,0x5c4dd124n,0x6d703ef3n,0x7a6d76e9n,0n];function ft(n,t,r,e){switch(!0){case 0n===e:return n^t^r;case 1n===e:return n&t|~n&r;case 2n===e:return(n|~t)^r;case 3n===e:return n&r|t&~r;case 4n===e:return n^(t|~r);default:throw new TypeError("Unknown I value: "+String(e))}}function ct(n,t){return 0xffffffffn&(n<<t|(0xffffffffn&n)>>32n-t)}function ut(n,t,r,e,i,a){var s=[];let o,f,c,u,h,l,y,d=n,g=t,w=r,m=e,p=i,v=n,b=t,x=r,A=e,E=i;for(let n=0;n<16;n++){const t=function(t){let r=0n;for(let n=t.length-1;0<=n;n--)r=256n*r+BigInt(t[n]);return BigInt(r)}(a.slice(4*n,4*(n+1)));s.push(t)}for(let n=0;n<80;n++)o=BigInt(n)>>4n,u=s[Number(rt[n])],h=st[Number(o)],l=s[Number(et[n])],y=ot[Number(o)],d=ct(d+ft(g,w,m,o)+u+h,it[n])+p,f=p,p=m,m=ct(w,10n),w=g,g=d,d=f,v=ct(v+ft(b,x,A,4n-o)+l+y,at[n])+E,c=E,E=A,A=ct(x,10n),x=b,b=v,v=c;return[t+w+A,r+m+E,e+p+v,i+d+b,n+g+x]}const ht=globalThis.crypto;async function lt(n,t="SHA-256",r=1,e=n=>n){let i,a=n instanceof ArrayBuffer?n:N.normalize(n).buffer;for(i=0;i<r;i++)e(a=await ht.subtle.digest(t,a));return new Uint8Array(a)}async function yt(n){return lt(n,"SHA-256")}function dt(n){{var r=n=N.normalize(n);let t=[0x67452301n,0xefcdab89n,0x98badcfen,0x10325476n,0xc3d2e1f0n];for(let n=0;n<r.length>>6;n++)t=ut(...t,r.slice(64*n,64*(n+1)));const i=[128,...new Array(119-r.length&63).fill(0)],a=Uint8Array.from([...r.slice(-64&r.length),...i,...tt(BigInt(8*r.length),8)]);for(let n=0;n<a.length>>6;n++)t=ut(...t,a.slice(64*n,64*(n+1)));var e=[];for(let n=0;n<t.length;n++){const i=0xffffffffn&t[n];e.push(...tt(i,4))}return Uint8Array.from(e)}}var gt={data:async function(n){return yt(N.serialize(n)).then(n=>new Uint8Array(n))},digest:lt,ripe160:dt,sha256:yt,sha512:async function(n){return lt(n,"SHA-512")},hash160:async function(n){return dt(await yt(n))},hash256:async function(n){return lt(n,"SHA-256",2)},hmac256:async function(n,t){n=await R.hmac(n,"SHA-256");return ht.subtle.sign("HMAC",n,N.normalize(t)).then(n=>new Uint8Array(n))},hmac512:async function(n,t){n=await R.hmac(n,"SHA-512");return ht.subtle.sign("HMAC",n,N.normalize(t)).then(n=>new Uint8Array(n))}};return n.Cipher=_,n.Field=k,n.Hash=gt,n.KeyPair=Qn,n.KeyUtil=R,n.Noble=Sn,n.Point=P,n.PubKey=nt,n.sign=$n,n.verify=Gn,n}({});